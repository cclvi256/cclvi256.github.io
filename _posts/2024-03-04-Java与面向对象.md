---
title: Java与面向对象
date: 2024-03-04 08:00:00 +0800
categories: [Software Construction, zh]
tags: [Java, Software Construction, OOP]
math: true
---

## 面向对象三大基本特征

> 面向对象的三大基本特征分别是 **Encapsulation, Inheritance, Polymorphism**, 用中文翻译可以译为**封装, 继承和多态**.
>
> 面向对象的概念大多过于抽象, 我在下文中将使用一些案例来说明.

### Encapsulation, 封装

#### 封装是什么?

封装, 指的一般是对于对象的封装. 一个对象具有其自身内部的**字段** (在Java中也可以称为**属性**, ADT设计的语境下称为***rep***), 也有可以在外部调用的操作. 一般来说外部可以使用的是由类提供的方法, 而直接操作类的字段是一种不安全的, 甚至可能是破坏性的行为. 所以, 设计类的时候, 应有意避免使用的时候对数据类型造成的破坏. 这样的行为可以称之为封装. 封装是面向对象最基本的要求. 
    
#### 封装的示例
        
和结构化的程序设计相比, 面向对象的程序设计更注重对象, 而非过程. 
        
下面用翁恺老师的举例来描述一下我对于封装的理解. 在结构化程序设计的领域, 如果需要让小明站起来, 笼统地说, 我们需要**操作小明的大脑发出指令**, **操作神经以传输指令**, 最后**操作肌肉以响应指令**, 最终小明站起来了. 
        
在面向对象的程序设计中, 小明的大脑, 神经和肌肉都是小明**私有**的, **不应该被外界直接访问**, 外界可以让小明站起来, 小明则应该按照实际情况选择**是否站起来**, **大脑**发出哪些指令, 哪些**神经**传输指令, 哪些**肌肉**响应指令等等, 都是小明需要自己处理的. 这也是符合人类思维的操作方式. 

在上述例子中, 使用面向对象的程序设计, 明显可以降低编码和协作的难度, 提高编码效率和代码可读性, 为日后的运维工作做出充足的准备. 

#### 封装的实现

封装的实现主要是依靠访问说明符. 访问说明符说明了一个类成员的可见性, 以及类的可见性, 访问策略等等. 
        
字段和方法的常见的访问说明符如下表. 

| 访问说明符 | 含义 |
| :-: | :-: |
| `public` | 对所有的类都是可见的 |
| `protected` | 在包内是可见的, 不同包的子类不能访问其实例的方法 |
| (缺省) | 在包内是可见的 |
| `private` | 在类内是可见的 |

注: 
- `private`和`protected`不能用来修饰类
- 子类的概念来自于后面提到的 "继承"
- 对于接口, 缺省的访问说明符是`public`

#### 为什么说C++不是一门完全面向对象的语言?

 这一切归功于C++中最强大的功能: 指针. 如果在C++中, 一个字段被设置为`private`, 但是你仍然可以通过指针在类的外部修改`private`字段的值. 但是Java等语言有JVM来确保`private`字段不会被意外访问. 

### Inheritance, 继承



### Polymorphism, 多态
   
#### 多态的分类

多态有多种存在的形式, 例如方法调用的多态, 泛型的多态, 子类型多态三种

#### 方法的重载
    
方法重载, 就是在同一个类中声明多个方法, 每一个同名方法的参数列表***必须不同***. 方法的重载实际上是为了节约协作成本, 让多种方法共用相同的方法名, 可以便于调用者的使用. 决定使用哪一个方法重载发生于静态类型检查时期. 也就是无论是否使用方法的重载, 都不会影响运行时的状态. 

一种特殊的情况是如果父类含有一个参数不同的同名方法, 那么这两个方法实际上也构成一种方法的重载. 类似地, 在重写`Object`类若干基础方法的时候, 一定要注意传入参数类型必须和`Object`的声明一致. (为了避免这样的情况发生, 推荐使用`@Override` Annotation)

#### 泛型
    
#### 子类型多态与Liskov可替代原则
    
Liskov可替代原则 (Liskov Substitution Principle, abbr: LSP) 是对于OOP中子类型多态的限制条件. 简言之, Liskov规则要求子类型有更严格的RI, 子类型的所有重写方法必须有比父类型更强的Spec. 展开来说一共有如下几条: 

- 子类型必须有比父类型更强的RI
- 子类型重写的方法必须有比父类型更弱的前置条件, 换言之子类型重写方法的参数类型可以是父类型方法参数类型, 也可以是其参数类型的父类型, 这称为 "反协变原则" 或 "逆变原则" (Contravarience Principle). 这种行为只有在理论上是允许的, 实际上Java会禁止这样的重写. 这时如果去掉`@Override` Annotation, Java又会认为这是一种方法重载, 无法达到其真实目的. 
- 子类型的重写方法必须有比父类型更强的后置条件, 即子类型重写方法的返回值类型可以是父类型方法的返回值类型, 也可以是父类型方法的返回值类型的子类型, 且子类型不能比父类型抛出更多的异常 (这里 "更多的异常" 不是指异常类的数量, 例如如果父类型方法抛出`Exception`, 子类型重写方法抛出`IOException`和`NullPointerException`, 子类型重写方法抛出的异常依然是比父类型方法少的). 
  
LSP在一定程度上不是一个强制性的规则, 而是一个面向可复用性的ADT设计规范. 






















